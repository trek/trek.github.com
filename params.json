{"note":"Don't delete this file! It's used internally to help with page regeneration.","name":"Trek","tagline":"","body":"# Advice on & Instruction in the Use Of Ember.js\r\n[Ember.js](http://emberjs.com/) – for the unaware – is an application framework\r\nfor building sophisticated browser applications. I'm a frequent contributor to\r\nthe project and use it professionally at my current gig with [Groupon\r\nEngineering](http://www.groupon.com/techjobs/#/about). This piece is part\r\ntutorial, part marketing pitch.\r\n\r\nThere's currently a lot of interest in Ember and its\r\nbrowser-application-crafting siblings as people are becoming more comfortable\r\nwith the browser as a legitimate application development platform and not merely a\r\nubiquitously deployed rendering engine for server-generated documents. [Not\r\neveryone](https://twitter.com/dhh/status/212655990766702594) thinks this pattern\r\nis viable moving forward, but I suspect interest in making this style of\r\napplication will only increase over time, become foolishly and inappropriately\r\noverused, before finally settling down as a useful addition to a developer's\r\ntoolset.\r\n\r\nI'm pretty convinced Ember will be the go-to choice for writing applications\r\nwith the sophistication, usefulness, and polish of products like\r\n[Rdio](http://www.rdio.com/), [Square](https://squareup.com/)'s web properties,\r\nor [Wunderkit](http://get.wunderkit.com/apps/). Ember is the only framework I've\r\nseen so far that is genuinely tackling the real and difficult requirements of UI\r\nEngineering. I don't say this to knock projects like\r\n[Batman](http://batmanjs.org/), [Knockout](http://knockoutjs.com/),\r\n[Angular](http://www.angularjs.org/), or [Backbone](http://backbonejs.org/).\r\nThey're quite good; I've played with all and used Backbone professionally.\r\n\r\nLike Ember, they're all experimenting with strategies for connecting data to\r\ndisplay and keeping the two synchronized – a notably difficult task. But only\r\nEmber is approaching this task in a larger scope of UI Engineering that involves\r\neven harder architecture concerns. This is part of what makes Ember.js\r\nchallenging for a learner to approach. Have you ever written an app that is\r\nlong-running, stateful, requires identity mapping, or must serialize state for\r\nlater re-entry? If you're like most web developers I meet, it's highly likely\r\nthese are all foreign or novel concepts for you. Even if you've encountered them\r\nbefore in a CS class or while doing iOS development you've probably never\r\ntranslated them into the browser environment.\r\n\r\nListen: it's not Ember that's hard. It's the concepts. When people tell me the\r\nlearning curve for Angular or Backbone is small, I call bullshit. Small for whom? Sure,\r\nBackbone is approachable if you've spent some time writing applications with jQuery\r\nand are familiar with callback-style evented architectures. Backbone's DNA is\r\nbasically [jQuery custom\r\nevents](http://css-tricks.com/custom-events-are-pretty-cool/) on steroids.\r\nAngular is a dream if you're accustomed to HTML `data-` style behavior like\r\nyou find as part of [Twitter Bootstrap's javascript](http://twitter.github.com/bootstrap/javascript.html)\r\n\r\nEven if Backbone fits squarely into your existing skill set – admittedly true\r\nfor most web developers – it's learning curve ramps up steeply if you're\r\ndedicated to writing robust applications. Ever run into [zombie events in a\r\nBackbone\r\napplication](http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/)?\r\nNo? You've either not used it for anything big, have [Rain\r\nMan](http://www.imdb.com/title/tt0095953/)-like ability to craft software, or\r\nare fucking shitting me.\r\n\r\nHere's an example of some of the view cleanup code in Rdio:\r\n\r\n``` javascript\r\ndestroy: function () {\r\n  var c = this;\r\n  this.unbind();\r\n  try {\r\n    this._element.pause(), \r\n    this._element.removeEventListener(\"error\", this._triggerError), \r\n    this._element.removeEventListener(\"ended\", this._triggerEnd), \r\n    this._element.removeEventListener(\"canplay\", this._triggerReady), \r\n    this._element.removeEventListener(\"loadedmetadata\", this._onLoadedMetadata), \r\n    _.each(b, function (a) {\r\n      c._element.removeEventListener(a, c._bubbleProfilingEvent)\r\n    }),\r\n    _.each(a, function (a) {\r\n      c._element.removeEventListener(a, c._logEvent)\r\n    }),\r\n    this._element = null,\r\n    this.trigger(\"destroy\")\r\n  } catch (d) {}\r\n}\r\n```\r\n\r\n\r\nIf this doesn't look familiar, you're in for a world of hurt when you try to\r\nparlay your Backbone skills into something Rdio-sized. Backbone is the best solution,\r\nhands down, for apps where the user comes to a page, interacts with the application\r\nfor a short time before moving on, letting the [views and the models get thrown\r\naway](https://github.com/documentcloud/backbone/issues/231). Beyond that,\r\nit requires increasing diligence and expertise on your part.\r\n\r\nSo, here's my pitch: I want you to learn Ember. Not instead of Backbone or\r\nAngular but _in addition to_ them. There's a lot of writing comparing the three,\r\nbut once you become familiar with them you'll see it's a totally nonsensical\r\ncomparison. Although their output is the same (i.e. a \"web app\") they just don't\r\nbelong in the same category.\r\n\r\nI apologize for the long preamble, but we're going to explore some concepts and\r\nI want to be sure you're willing to allow that their strangeness is not due to\r\nthe poor architecture of Ember but to your unfamiliarity with them. If you're\r\nwilling to learn no matter how funky weird things appear at first, read on. If\r\nyou're looking to troll then just skim on: you'll find _lots_ of things to\r\nhighlight [when you create a troll twitter account with a single post maligning\r\na tool you've never bothered to\r\nexplore](https://twitter.com/delambro/status/234997274051219456).\r\n\r\n## The Smallest Viable Ember Application\r\nThe smallest possible Ember application of interest can be describe thus:\r\n\r\n```javascript\r\nApp = Ember.Application.create();\r\n\r\nApp.ApplicationView = Ember.View.extend({\r\n  templateName: 'application'\r\n});\r\nApp.ApplicationController = Ember.Controller.extend();\r\n\r\n\r\nApp.Router = Ember.Router.extend({\r\n  root: Ember.Route.extend({\r\n    index: Ember.Route.extend({\r\n      route: '/'\r\n    })\r\n  })\r\n});\r\n\r\nApp.initialize();\r\n```\r\n    \r\nAnd in our HTML document body or head:\r\n    \r\n```html\r\n<script type=\"text/x-handlebars\" data-template-name=\"application\">\r\n      \r\n</script>\r\n```\r\n\r\nLet's examine each piece in isolation.\r\n\r\n```javascript\r\nApp = Ember.Application.create();\r\n```\r\nThis line creates a new instance of `Ember.Application`. `Application` does two handy things:\r\n  \r\n  * provides a single location for all your objects so we avoid [polluting the global namespace](https://www.google.com/search?q=don't+pollute+the+global+namespace).\r\n  * creates a single listener for each user event (e.g. 'click') and [controls event delegation](https://www.google.com/search?q=event+delegation).\r\n\r\n&nbsp;\r\n\r\n```javascript\r\nApp.ApplicationView = Ember.View.extend({\r\n  templateName: 'application'\r\n});\r\n```    \r\nViews in Ember are responsible for:\r\n  \r\n   * determining the structure of a section of the application's rendered HTML.\r\n   * responding to delegated user events.\r\n   \r\nIn the above view we will change structure of the page only through the view's\r\ntemplate, which will render as the contents of the view's tag, but we could also\r\nprovide a different tag name, id, css class, or other HTML attributes for the\r\nrendered element.\r\n\r\nYour application _must_ have an `ApplicationView` property. An instance of this\r\nclass will be created for you and inserted into the application's view hierarchy\r\nas the root view.\r\n\r\n```javascript\r\nApp.ApplicationController = Ember.Controller.extend();\r\n```\r\n\r\nEvery view has a rendering context. This is the object where Handlebars\r\ntemplates will look for properties. So, if your template looks like this:\r\n    \r\n    {{name}}\r\n    \r\nand its rendering context has a `name` property, you'll see the value outputted.\r\nIf there is no property, you'll see nothing.\r\n\r\nA single instance of `ApplicationController` will be created for you and\r\nautomatically set as the rendering context of the `ApplicationView`. This is\r\nobvious but bears mentioning: your application _must_ have an\r\n`ApplicationController` property. If it lacked one, the application's root view\r\nwould have no rendering context and would be pretty useless except for\r\ndisplaying static content. Ember enforces the presence of this property by\r\nthrowing an error if it's missing.\r\n\r\n```javascript\r\nApp.Router = Ember.Router.extend({\r\n  root: Ember.Route.extend({\r\n    index: Ember.Route.extend({\r\n      route: '/'\r\n    })\r\n  })\r\n});\r\n```\r\n\r\nA `Router` in Ember behaves significantly different than you probably suspect\r\nif you have experience with other javascript libraries using the 'router' label.\r\nEmber's `Router` class is a subclass of its more general purpose `StateManager`.\r\nMost browser-routers are just copying the routing pattern from familiar server\r\ntechnologies. But HTTP is specifically a [stateless\r\nprotocol](http://en.wikipedia.org/wiki/Stateless_protocol) and the techniques\r\nfor routing on the server are missing important abilities when translated into\r\nthe stateful environment of browser application development.\r\n\r\nYour application's router is responsible for tracking the state of your\r\napplication and affecting the application's view hierarchy in response to state\r\nchange. It is also responsible for serializing this state into a single string –\r\nthe URL – and for later deserializing the string into a usable application\r\nstate. Rather than being a central organizing technique, URLs are just a useful\r\nside effect of state change.\r\n\r\nStates are the central feature of an Ember application. Yes, property\r\nobservations and automatic view updates are handy, but if that's all Ember\r\noffered it would be only a fraction as useful for serious and robust development.\r\n\r\n```javascript\r\n...\r\nroot: Ember.Route.extend({\r\n  index: Ember.Route.extend({\r\n    route: '/'\r\n  })\r\n})\r\n...\r\n```\r\n\r\nYour router must have these two routes. The first, `root`, really just acts as a\r\ncontainer for all subsequent routes. You can think of it as the route set,\r\nrather than a proper route itself. The second `index`, can be called whatever\r\nyou like. The key feature is that it has a `route` property of `'/'`. When your\r\napplication loads, Ember will being looking through its internal route maps to\r\nfind one that matches the url in the browser. If you enter the application at\r\nthe url `'/'` your Router will automatically transition into this state.\r\n    \r\n```javascript\r\nApp.initialize();\r\n```\r\n    \r\nFinally, calling `initialize` on your application starts the application's\r\nrouting process, sets up the necessary internal structure based on configuration\r\nwe've done earlier, and inserts an instance of your `ApplicationView` (with an\r\ninstance of `ApplicationController` as its rending context) into the page.\r\n\r\n## Building Up An Application\r\nFrom here, we can start building up an application by adding states to our\r\nrouter, navigable elements in our templates to allow a user to begin\r\nmanipulating states, and views that are inserted in response to these state\r\nchanges. We'll create a tiny application that lets you see information about\r\ncommitters to the main Ember repository.\r\n\r\nLet's start that process by adding some markup and an `outlet` into our\r\ncurrently empty `application` template:\r\n\r\n\r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"application\">\r\n  <h1>Ember Committers</h1>\r\n  {{outlet}}\r\n</script>\r\n```\r\n\r\nAn `outlet` helper defines sections of a template where we will change specific\r\nportions of the view hierarchy in response to state change. Any template (not\r\njust the root one) can have any number of outlets (if you give them names). This\r\nlets you express really nuanced view hierarchies with minimal effort.\r\n\r\nNext, add a view for all contributors and a matching controller and template:\r\n\r\n```javascript\r\nApp.AllContributorsController = Ember.ArrayController.extend();\r\nApp.AllContributorsView = Ember.View.extend({\r\n  templateName: 'contributors'\r\n});\r\n```\r\n```handlebars    \r\n// in your page body or head:\r\n<script type=\"text/x-handlebars\" data-template-name=\"contributors\">\r\n  {{#each person in controller}}\r\n    {{person.login}}\r\n  {{/each}}\r\n</script>\r\n```\r\n  \r\nWithin the state that matches for the index path (`'/'`), implement a\r\n`connectOutlets` method. It takes a single argument that will be your\r\napplication's router. Within that method get the single instance of our\r\n`ApplicationController` class and connect its outlet with the `connnectOutlet`\r\nmethod:\r\n\r\n\r\n```javascript\r\nindex: Ember.Route.extend({\r\n  route: '/',\r\n  connectOutlets: function(router){\r\n    router.get('applicationController').connnectOutlet('allContributors', [{login:'wycats'},{login:'tomdale'}]);\r\n  }\r\n})\r\n```\r\n\r\nGive your application a reload. You won't see much yet, but this will let you\r\ncatch any console errors now.\r\n\r\nLet me assuage your obvious fears right now: Yes, this is a lot of code. Yes, it\r\nseems weirdly complex. Yes, you could accomplish this same trivial task in\r\nBackbone or Angular with far less code. Ember isn't targeting applications with\r\nthis minimal level of sophistication so it seems foolishly verbose when starting\r\nout.\r\n\r\nThat said, this is the _single_ central pattern to an application. Once you\r\nmaster it, you'll be cranking out applications like a pro. Ember applications\r\nstart out with a complexity rating of 4/10 but never get much higher than 6/10,\r\nregardless of how sophisticated your application becomes. Backbone starts out at\r\n1/10 but complexity grows linearly. This is a natural side effect of the types\r\nof applications the two frameworks were specifically created for.\r\n\r\nLet's unpack our new code, in reverse:\r\n\r\n```javascript\r\nindex: Ember.Route.extend({\r\n  route: '/',\r\n  connectOutlets: function(router){\r\n    router.get('applicationController').connnectOutlet('allContributors', [{login:'wycats'},{login:'tomdale'}]);\r\n  }\r\n})\r\n```\r\n\r\nWhen your application is loaded at the url `'/'`, Ember will automatically\r\ntransition the application into the state I've called `index`. `connectOutlets`\r\nis called on this state. It acts as a callback for us to connect sections of our\r\nview hierarchy (designated with `{{outlet}}`) to specific views based on the\r\nstate. In this case I want to connect the `{{outlet}}` in our application\r\ntemplate with markup for all our contributors so I access the application's\r\nsingle shared instance of `ApplicationController` and call `connnectOutlet` on\r\nit with `'allContributors'` as an argument.\r\n\r\nWhen our application is `initialize`ed, a single shared instance of each\r\ncontroller is created for us. Because you'll most likely access this instance\r\nfrom the router, it's placed as a property of the router with a name that\r\nmatches the controller's classname but converted to lower-camel style:\r\n`ApplicationController`'s single instance is stored as `applicationController`.\r\n\r\nControllers have the ability to connect outlets in the views they control. In the\r\nabove example, I'm calling `connnectOutlet` with `'allContributors'` as an argument.\r\nThis will create an instance of `AllContributorsView` for us, set the shared instance of\r\n`AllContributorsController` as the view's default rendering context, and insert\r\nit into our view hierarchy at the point where `{{outlet}}` appears in the\r\napplication template. The second argument, which I've hard coded as an array of\r\ntwo object literals, is set as the `content` of the controller instance. (Those\r\nwho fear this kind of \"magic\" are free to read the documentation for Controllers\r\nto see the full, maximally verbose and explicit arguments you can pass).\r\n\r\n```javascript\r\nApp.AllContributorsController = Ember.ArrayController.extend();\r\nApp.AllContributorsView = Ember.View.extend({\r\n  templateName: 'contributors'\r\n});\r\n```\r\n\r\nThe `AllContributorsController` is a subclass of Ember's `ArrayController` class.\r\n`ArrayController`s acts as containers for any array-like object in Ember and\r\nsimply proxy undefined properties or methods to the underlying `content` array.\r\n\r\nIn our template, the each call (`{{each person in controller}}`) is passed along\r\nto the `content` of our ArrayController which I've hard-coded as an array of two\r\nobject literals with a single property each.\r\n\r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"contributors\">\r\n  {{#each person in controller}}\r\n    {{person.login}}\r\n  {{/each}}\r\n</script>\r\n```\r\n\r\n## Loading External Data\r\nEmber gets a lot of flack for it's lack of \"a persistence layer\" when compared\r\nto Backbone or Batman. I've never thought of this as fair criticism because I\r\ndon't think of thin wrappers around `$.ajax()` that follow a Rails-style-REST\r\npattern really merit the \"persistence layer\" label. And many other frameworks\r\nare starting to realize this too as their thin `$.ajax()` delegation is being\r\nfleshed out to handle the [real and difficult problems of reliably synchronizing\r\ndata between two environments when there are few structural standards to rely\r\non](https://plus.google.com/u/0/106300407679257154689/posts/Hv6xvZsuBBF).\r\n\r\nThe real, valid criticism is that nobody who knows Ember has offered much\r\nguidance for how to handle data loading within an Ember application. Ember, as\r\nI'm trying to convince you, has valuable patterns you've never used before and\r\nit's totally unfair to maintain this assertion while simultaneously expecting\r\nyou to know how to combine these patterns with data loading solutions you've\r\npreviously used.\r\n\r\nThe best advice I can offer is: always be returning.\r\n\r\nEmber relies on the immediate availability of data objects even if the\r\nunderlying content of those objects is still loading. This is almost certainly\r\ndifferent than asynchronous patterns for data loading you've used\r\nbefore. Let's step through how this works, one concern at a time.\r\n\r\nIn our application so far, I've punted on data and just hard coded something\r\ninto our index state:\r\n\r\n\r\n```javascript\r\nindex: Ember.Route.extend({\r\n  route: '/',\r\n  connectOutlets: function(router){\r\n    router.get('applicationController').connnectOutlet('allContributors', [{login:'wycats'},{login:'tomdale'}]);\r\n  }\r\n})\r\n```\r\n    \r\nI'd much prefer to delegate that data loading out to a proper object. Let's call\r\nto a – as yet unimplemented – `Contributor` class and a `find` method on that class:\r\n\r\n\r\n```javascript\r\nindex: Ember.Route.extend({\r\n  route: '/',\r\n  connectOutlets: function(router){\r\n    router.get('applicationController').connnectOutlet('allContributors', App.Contributor.find());\r\n  }\r\n})\r\n```\r\n    \r\n\r\nAnd now implement this object:\r\n\r\n```javascript\r\nApp.Contributor = Ember.Object.extend();\r\nApp.Contributor.reopenClass({\r\n  find: function(){}\r\n});\r\n```\r\n\r\nThis creates a new class and reopens that class to add class (sometimes called\r\n'static') method:\r\n\r\nIf you reload your application you'll see that nothing renders now. This is\r\nbecause we've set the `content` of our `AllContributorsController` to undefined\r\nwhich is the default return value of our new `find` method. Let's apply some\r\n`$.ajax` to the method:\r\n\r\n\r\n```javascript\r\nApp.Contributor.reopenClass({\r\n  find: function(){\r\n    $.ajax({\r\n      url: 'https://api.github.com/repos/emberjs/ember.js/contributors',\r\n      dataType: 'jsonp',\r\n      success: function(response){\r\n        return response.data;\r\n      }\r\n    })\r\n  }\r\n});\r\n```\r\n\r\nReload your application and you'll see there is still no change because,\r\nalthough we request data, `find` still has no return value. It's here that\r\npeople usually code themselves into a corner trying to get their previous\r\nexperience with ajax to fit into Ember patterns, give up, and post a\r\nStackOverflow question.\r\n\r\nThere are a few solutions to this problem but the easiest for us now is to just\r\nmake sure we're returning an array:\r\n\r\n\r\n```javascript\r\nApp.Contributor.reopenClass({\r\n  allContributors: [],\r\n  find: function(){\r\n    $.ajax({\r\n      url: 'https://api.github.com/repos/emberjs/ember.js/contributors',\r\n      dataType: 'jsonp',\r\n      context: this,\r\n      success: function(response){\r\n        response.data.forEach(function(contributor){\r\n          this.allContributors.addObject(App.Contributor.create(contributor))\r\n        }, this)\r\n      }\r\n    })\r\n    return this.allContributors;\r\n  }\r\n});\r\n```\r\n\r\nI've changed `find` to immediately return an array (`this.allContributors`) which\r\nstarts out empty. This will become the `content` of our controller, which is the\r\ndefault rendering context for the view. When the view first renders it will loop\r\nover the empty array and insert nothing into the page. When the ajax call is\r\nsuccessful we loop through the response from the server turning each chunk\r\nof JSON into an instance of our `Contributor` class, and add it to the array.\r\nEmber's property notification system will trigger a view re-render for just the\r\naffected sections of the page.\r\n\r\nBecause Ember has a good property observation system we can handle the\r\nasynchronicity from multiple points within the application structure where it's\r\nmost appropriate rather than being forced to handle it at the communication\r\nlayer.\r\n\r\nIf you reload the application you'll see an empty page before the view updates\r\nwhen the data is loaded. If we were writing a slightly more complex application,\r\nwe could use a library by the core team called [Ember\r\nData](https://github.com/emberjs/data) that would help with functionality like\r\nbinding loading state to view display. It has far more ambitious goals than\r\nwe'll need for demonstration: stateful data synchronization, property encoding\r\nand decoding, identity mapping, transactional communication, and more.\r\n\r\n## Transitioning Between States\r\nWith data in hand, we can now allow users to transition between the state where\r\nthey see all contributors to a state where they see just one contributor. Our\r\ncurrent router looks like this\r\n\r\n```javascript\r\nApp.Router = Ember.Router.extend({\r\n  root: Ember.Route.extend({\r\n    index: Ember.Route.extend({\r\n      route: '/',\r\n      connectOutlets: function(router){\r\n        router.get('applicationController').connnectOutlet('allContributors', App.Contributor.find());\r\n      }\r\n    })\r\n  })\r\n});\r\n```\r\n    \r\nWe'll add a sibling state to index for viewing just a single contributor. I'm\r\nalso going to rename 'index' to the more descriptive state name of\r\n'contributors':\r\n\r\n\r\n```javascript\r\nApp.Router = Ember.Router.extend({\r\n  root: Ember.Route.extend({\r\n    contributors: Ember.Route.extend({\r\n      route: '/',\r\n      connectOutlets: function(router){\r\n        router.get('applicationController').connnectOutlet('allContributors', App.Contributor.find());\r\n      }\r\n    }),\r\n        \r\n    aContributor: Ember.Route.extend({\r\n      route: '/:githubUserName',\r\n      connectOutlets: function(router, context){\r\n        router.get('applicationController').connnectOutlet('oneContributor', context);\r\n      }\r\n    })\r\n    \r\n  })\r\n});\r\n```\r\n    \r\nExamining this new state in isolation:\r\n\r\n```javascript\r\naContributor: Ember.Route.extend({\r\n  route: '/:githubUserName',\r\n  connectOutlets: function(router, context){\r\n    router.get('applicationController').connnectOutlet('oneContributor', context);\r\n  }\r\n})\r\n```\r\n      \r\nI've supplied a `route` property of `':/githubUserName'`, which we'll use later\r\nto serialize and deserialize this state. I've implemented the `connectOutlets`\r\nmethod with two arguments: one to represent the entire router and one, called\r\n`context`, which will help answer the question \"_which_ contributor\" later on.\r\nInside `connectOutlets` I've accessed the shared instance of\r\n`ApplicationController` and used it to connect the outlet in its view (an\r\ninstance of `ApplicationView`) to a pairing of\r\n`OneContributorView`/`OneContributorController`, which are unimplemented.\r\n\r\nNext, we'll update the application template to include a way for users to change\r\nthe application's state from 'contributors' to 'aContributor' through\r\ninteraction. Currently our template just loops and prints the `login` property\r\nof each contributor:\r\n\r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"contributors\">\r\n  {{#each person in controller}}\r\n    {{person.login}}\r\n  {{/each}}\r\n</script>\r\n```\r\n      \r\nWe're going to encase that login in an `<a>` tag that includes a call to the\r\n`{{action}}` helper:\r\n\r\n  \r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"contributors\">\r\n  {{#each person in controller}}\r\n    <a {{action showContributor person}}> {{person.login}} </a>\r\n  {{/each}}\r\n</script>\r\n```\r\n\r\nThe `{{action}}` helper goes _within_ the opening tag of an element (here, the\r\n`<a>`) and takes two arguments. The first, `showContributor`, is the action we'd\r\nlike to send to the current state of the application and the second, `person`,\r\nwill become the `context` argument passed through various callbacks in the\r\napplication's router.\r\n\r\nIf you reload the application now you'll see that our logins have become links.\r\nWith your console enabled, click any of the links. You'll see a warning that\r\nyour application's router 'could not respond to event showContributor in state\r\nroot.contributors'.\r\n\r\nAdd this transition action to the 'contributors' state. I like to put my actions\r\nbetween route property definition and route API callbacks like\r\n`connectOutlets`:\r\n\r\n\r\n```javascript\r\ncontributors: Ember.Route.extend({\r\n  route: '/',\r\n      \r\n  showContributor: Ember.Route.transitionTo('aContributor'),\r\n      \r\n  connectOutlets: function(router){\r\n    router.get('applicationController').connnectOutlet('allContributors', App.Contributor.find());\r\n  }\r\n})\r\n```\r\n\r\n\r\nThe new action is written for us by the static method `transitionTo` on\r\nthe `Ember.Route` class. You can write your transitions yourself (they're just\r\nfunctions), but `Ember.Route.transitionTo` saves you trouble of hand-writing\r\na lot of similar looking functions.\r\n\r\nPop back to the browser, reload the application, and try to transition again.\r\nThis time, you'll be warned that we're missing our `OneContributorView` class.\r\nThe transition has occurred and we've reached the `connectOutlets` callback\r\non the 'aContributor' state, but cannot properly connect our outlet yet without\r\nthe missing view class.\r\n\r\nImplement this class and matching controller and template:\r\n\r\n```javascript\r\nApp.OneContributorView = Ember.View.extend({\r\n  templateName: 'a-contributor'\r\n});\r\nApp.OneContributorController = Ember.ObjectController.extend();\r\n```\r\n```handlebars    \r\n// in your HTML document\r\n<script type=\"text/x-handlebars\" data-template-name=\"a-contributor\">\r\n  {{login}} - {{contributions}} contributions to Ember.js\r\n</script>\r\n```\r\n    \r\nI've made `OneContributorController` an instance of `Ember.ObjectController`.\r\n`ObjectController` is like `ArrayController` – a tiny wrapper for objects that will\r\njust proxy property and method access to its underlying `content` property – but\r\nfor single objects instead of collections.\r\n\r\nIf you reload the application and try to transition you should have more\r\nsuccess. It might be handy to enable logging on your router to get a better feel\r\nfor what is happening on transitions:\r\n\r\n```javascript\r\nApp.Router = Ember.Router.extend({\r\n   enableLogging: true,\r\n   // other properties added earlier\r\n})\r\n```\r\n\r\nLet's unpack what's going on when we click that link. Ember has registered\r\nlistener on the `<a>` element for you (so, no, this is nothing like going back\r\nto _ye olde onclick_ days) that will call the matching action name\r\n(`showContributor`) on the `target` property of the view. It just so happens\r\nthat the default target for any view is the application's router.\r\n\r\nThe router will delegate this action name to the current state. If the action is\r\npresent on the state, it will be called with the object you provided as the\r\nsecond argument to `{{action}}` as a context argument. If it's not present, the\r\nrouter will walk up through the state tree towards `root` looking for a matching\r\naction name.\r\n\r\nSince our state _does_ have a matching name, \r\n`showContributor: Ember.Route.transitionTo('aContributor')`, it's called. This function\r\ntransitions the router to the name state ('aContributor') and calls its\r\n`connectOutlets` callback with the router as the first argument and the context\r\nfrom the `{{action}}` helper as the second argument:\r\n\r\n```javascript\r\nconnectOutlets: function(router, context){\r\n  router.get('applicationController').connnectOutlet('oneContributor', context);\r\n}\r\n```\r\n    \r\nWithin this method, we access the single shared instance of\r\n`ApplicationController` and connect the outlet in its view (an instance of\r\n`ApplicationView`) by inserting an instance of `OneContributorView` with the\r\nsingle shared instance of `OneContributorController` as its default rendering\r\ncontext.\r\n\r\nThe `content` property of this controller is set to the passed `context`\r\nargument. Since `OneContributorController` is a descendant of\r\n`ObjectController`, property access in the view will proxy through the\r\ncontroller to this `content`.\r\n\r\nThe view renders and we see our updated view hierarchy in the browser.\r\n\r\n## Serializing and Deserializing States\r\nObservant readers will notice that, although we supplied a `route: '/:githubUserName'` \r\nproperty on our current state, the URL displayed\r\nin the browser has updated to a value of '#/undefined'. I mentioned\r\nearlier that URLs were just a pleasant side effect of state changes\r\nbut we haven't talked about serializing and deserializing states yet.\r\n\r\nAfter an application state is entered and `connectOutlets` has been called, the\r\nrouter will call `serialize` on the state with the router itself as the first\r\nargument and the current context as the second argument. There is a default\r\nimplementation of `serialize` that does property lookup on the context using any\r\ndynamic slugs in the supplied `route` property as keys.\r\n\r\nTo have serialization work we can either update our `route` to include dynamic\r\nslugs that match known properties on the object or implement our own custom\r\nmethod.\r\n\r\n\r\n```javascript\r\naContributor: Ember.Route.extend({\r\n  route: '/:githubUserName',\r\n  connectOutlets: function(router, context){\r\n    router.get('applicationController').connnectOutlet('oneContributor', context);\r\n  },\r\n  serialize: function(router, context){\r\n    return {\r\n      githubUserName: context.get('login')\r\n    }\r\n  }\r\n})\r\n```\r\n\r\nThe return value from a custom `serialize` method must be an object literal with\r\nkeys that match any dynamic slugs in the supplied `route`. The value for these\r\nkeys will be placed in the url.\r\n\r\nBrowse back to the root state of your application (i.e. go back to '/'), \r\nreload the application, and navigate back to the 'aContributor' state for any \r\ncontributor. The url should update properly.\r\n\r\nUnfortunately if you reload the application at this particular state you'll see\r\nthe URL updates to '#/undefined' again.\r\n\r\nWhen we load an Ember application at a particular url it will attempt to match\r\nand transition into a state with matching `route` pattern and call the state's\r\n`connectOutlets` and `serialize` callbacks. When we reload at '#/kselden', for\r\nexample, The router matches to the state with the `route` pattern of\r\n'/:githubUserName', transitions into it, then calls `connectOutlets` with the\r\nrouter as the first argument and a second argument of ... no context at all.\r\nFinally, `serialize` is called, also with an `undefined` context, and the\r\nproperty `githubUserName` is accessed on `undefined` and the URL is updated to\r\n'#/undefined'.\r\n\r\nEntering the application at a particular URL doesn't give our application access\r\nto previous loaded data so to fully load the matching state, we need to\r\nre-access this data. States have a callback `deserialize` for doing just this.\r\nThere's a default implementation, but we can implement our own custom one as\r\nwell:\r\n\r\n\r\n```javascript\r\naContributor: Ember.Route.extend({\r\n  route: '/:githubUserName',\r\n  connectOutlets: function(route, context){\r\n    router.get('applicationController').connnectOutlet('oneContributor', context);\r\n  },\r\n  serialize: function(router, context){\r\n    return {githubUserName: context.get('login')}\r\n  },\r\n  deserialize: function(router, urlParams){\r\n    return App.Contributor.findOne(urlParams.githubUserName);\r\n  }\r\n})\r\n```\r\n    \r\n    \r\nAbove, I've mocked out what I want this deserialization interface to look like.\r\nI'll call `App.Contributor.findOne` with the section of our url represented by\r\n`githubUserName` and return this object. The return value of `deserialize`\r\nbecomes the `context` passed to `connectOutlets`, so I must immediately return\r\nan object that will get populated with data later. Let's add\r\n`App.Contributor.findOne` to allow for passing a Github user name. \r\n\r\nGithub allows us to access a user at '/users/*a name*', but this isn't within\r\nthe context of a particular repository, so we won't have access to this users\r\ncontribution count, which is part of the data we need. To see a particular\r\nusers in the context of a repository we'll need to load them all and locally\r\nfind the one we're looking for. This isn't exactly ideal, but unless you\r\ncontrol development of both client and server it's typical.\r\n\r\n\r\n```javascript\r\nfindOne: function(username){\r\n  var contributor = App.Contributor.create({\r\n    login: username\r\n  });\r\n  \r\n  $.ajax({\r\n    url: 'https://api.github.com/repos/emberjs/ember.js/contributors',\r\n    dataType: 'jsonp',\r\n    context: contributor,\r\n    success: function(response){\r\n      this.setProperties(response.data.filterProperty('login', username));\r\n    }\r\n  })\r\n            \r\n  return contributor;\r\n}\r\n```\r\n    \r\nThe order of execution for this method is: create a new `Contributor` object with\r\n`login` set immediately to the known value passed in as `username` from within\r\nthe 'aContributor' states's deserialize method. Then we set up some ajax and\r\nimmediately return the `Contributor` instance. When the ajax completes we find\r\njust the contributor we're interested in and update the returned `Contributor`\r\ninstance's properties with `setProperties`, which will trigger a view update of\r\nany sections bound to properties whose values have changed.\r\n\r\n## Repeat\r\nThat's an Ember application. States, transitioning between them, and\r\nloading data when you need it. You can build up surprisingly sophisticated and\r\nrobust UIs by repeating this process until you're happy. Let's repeat this by\r\nadd a \"back to all contributors\" navigation to our template for a single contributor:\r\n\r\nRight now the template is pretty simple:\r\n    \r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"a-contributor\">\r\n  {{login}} - {{contributions}} contributions to Ember.js\r\n</script>\r\n```\r\n\r\nLet's add an element with an action to transition back to the 'contributors'\r\nstate:\r\n\r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"a-contributor\">\r\n  <div>\r\n    <a {{action showAllContributors}}>All Contributors</a>\r\n  </div>\r\n  {{login}} - {{contributions}} contributions to Ember.js\r\n</script>\r\n```\r\n    \r\nAdd this action to the 'aContributor' state:\r\n    \r\n```javascript\r\naContributor: Ember.Route.extend({\r\n  route: '/:githubUserName',\r\n  \r\n  showAllContributors: Ember.Route.transitionTo('contributors')\r\n      \r\n  // ... remainder of this object's properties\r\n})\r\n```\r\n\r\nDone.\r\n\r\nNested states are possible and encouraged as well. They come with only one\r\ncaveat: you must end the transition between states on state that is a 'leaf'\r\n(i.e. has no child states of its own). As you convert states into more complex\r\nsets of nested states, either remember to directly transition to one of the\r\nchild states or set an `initialState` property.\r\n\r\nLet's convert our simple 'aContributor' state into a more complex object with\r\ntwo child states. The parent 'aContributor' we'll use for fetching a contributor\r\nand displaying her name and number of commits. Then we'll provide two nested\r\nstates: one – 'details' – for viewing additional details about the contributor\r\nand a second – 'repos' – for showing a list of their repositories.\r\n\r\nFor reference, the 'aContributor' state looks like this:\r\n\r\n```javascript\r\naContributor: Ember.Route.extend({\r\n  route: '/:githubUserName',\r\n  connectOutlets: function(router, context){\r\n    router.get('applicationController').connnectOutlet('oneContributor', context);\r\n  },\r\n  serialize: function(router, context){\r\n    return {githubUserName: context.get('login')}\r\n  },\r\n  deserialize: function(router, urlParams){\r\n    return App.Contributor.findOne(urlParams.githubUserName);\r\n  },\r\n})\r\n```\r\n\r\nAnd we'll change it to this:\r\n\r\n```javascript\r\naContributor: Ember.Route.extend({\r\n  route: '/:githubUserName',\r\n  connectOutlets: function(router, context){\r\n    router.get('applicationController').connnectOutlet('oneContributor', context);\r\n  },\r\n  serialize: function(router, context){\r\n    return {githubUserName: context.get('login')}\r\n  },\r\n  deserialize: function(router, urlParams){\r\n    return App.Contributor.findOne(urlParams.githubUserName);\r\n  },\r\n      \r\n  // child states\r\n  initialState: 'details',\r\n  details: Ember.Route.extend({\r\n    route: '/',\r\n    connectOutlets: function(router){\r\n      router.get('oneContributorController').connectOutlet('details');\r\n    }\r\n  }),\r\n  repos: Ember.Route.extend({\r\n    route: '/repos',\r\n    connectOutlets: function(router){\r\n      router.get('oneContributorController').connectOutlet('repos');\r\n    }\r\n  })\r\n})\r\n```\r\n\r\nExamining each state in isolation:\r\n    \r\n    \r\n```javascript\r\ninitialState: 'details',\r\ndetails: Ember.Route.extend({\r\n  route: '/',\r\n  connectOutlets: function(router){\r\n    router.get('oneContributorController').connectOutlet('details');\r\n  }\r\n})\r\n```\r\n    \r\nWhen we transition into 'aContributor', its callbacks (`connectOutlets`,\r\n`serialize`, optionally `deserialize` if we're transitioning during application\r\nload) are called. This means the `{{outlet}}` in our application template is\r\nfilled with an instance of `OneContributorView` with the shared instance of\r\n`OneContributorController` used as its default rendering context. The `context`\r\nargument is passed from the `{{action showContributor contributor}}`, through\r\nthe transition, and into this callback. We then pass it along as the second\r\nargument to `connnectOutlet` and it becomes the `content` property of the shared\r\n`OneContributorController` instance.\r\n\r\nThen, because we have `initialState` defined the router immediately transitions\r\ninto the state 'aContributor.details' and calls its `connectOutlets` callback:\r\n  \r\n```javascript\r\nconnectOutlets: function(router){\r\n  router.get('oneContributorController').connectOutlet('details');\r\n}\r\n```\r\n    \r\nIn this callback we're connecting an `{{outlet}}` that we'll place inside the\r\ntemplate for a contributor (yes, outlets can be nested inside other outlets as\r\ndeeply as you'd like to). Go ahead and change\r\n\r\n    \r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"a-contributor\">\r\n  <div>\r\n    <a {{action showAllContributors}}>All Contributors</a>\r\n  </div>\r\n  {{login}} - {{contributions}} contributions to Ember.js\r\n</script>\r\n```\r\n    \r\nto\r\n\r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"a-contributor\">\r\n  <div>\r\n    <a {{action showAllContributors}}>All Contributors</a>\r\n  </div>\r\n  {{login}} - {{contributions}} contributions to Ember.js\r\n      \r\n  <div>\r\n    {{outlet}}\r\n  </div>\r\n</script>\r\n```\r\n\r\n\r\nAnd add `DetailsView` and template. You can skip creating a `DetailsController`.\r\nIn the absence of a controller with a matching name, Ember will just use the\r\nrendering context of the parent template, which in our case is the shared\r\ninstance of `OneContributorController` with its `context` property already set\r\nto the contributor we're interested in:\r\n\r\n\r\n```javascript\r\nApp.DetailsView = Ember.View.extend({\r\n  templateName: 'contributor-details'\r\n})\r\n```\r\n    \r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"contributor-details\">\r\n  <p>{{email}}</p>\r\n  <p>{{bio}}</p>\r\n</script>\r\n```\r\n\r\nReload the app and navigate to the 'aContributor.details' state by clicking on a\r\nGithub username. If you have `enableLogging` on for your router you'll see we've\r\nsuccessfully transitioned into the state but are missing the `email` and `bio`\r\ndata. Unfortunately, these properties are not part of the contributor data that\r\ncomes from Github. We'll need to trigger a call to Github when we enter this\r\nstate to fetch additional details. Let's stub out a call to this in the\r\n`connectOutlets` for 'aContributor.details':\r\n\r\n\r\n```javascript\r\nconnectOutlets: function(router){\r\n  router.get('oneContributorController.content').loadMoreDetails();\r\n  router.get('oneContributorController').connectOutlet('details');\r\n}\r\n```\r\n    \r\nAnd add this method to our `Contributor` model:\r\n    \r\n```javascript\r\nApp.Contributor = Ember.Object.extend({\r\n  loadMoreDetails: function(){\r\n    $.ajax({\r\n      url: 'https://api.github.com/users/%@'.fmt(this.get('login')),\r\n      context: this,\r\n      dataType: 'jsonp',\r\n      success: function(response){\r\n        this.setProperties(response.data);\r\n      })\r\n    })\r\n  }\r\n});\r\n```\r\n    \r\nNow when we enter this state we'll trigger a call to load more data from Github,\r\nimmediately render the view, and the view will automatically update when\r\nadditional properties eventually have values. You can now reload the application\r\nand transition to this state again to see the updated view.\r\n\r\nWhat about transitioning between our 'aContributor.details' and\r\n'aContributor.repos' state? This should begin to look boringly familiar soon.\r\nUpdate our view to provide some navigational elements. Currently it looks like\r\nthis:\r\n\r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"a-contributor\">\r\n  <div>\r\n    <a {{action showAllContributors}}>All Contributors</a>\r\n  </div>\r\n  {{login}} - {{contributions}} contributions to Ember.js\r\n    \r\n  <div>\r\n    {{outlet}}\r\n  </div>\r\n</script>\r\n```\r\n\r\nAnd after we've added two actions:\r\n\r\n```handlebars\r\n<script type=\"text/x-handlebars\" data-template-name=\"a-contributor\">\r\n  <div>\r\n    <a {{action showAllContributors}}>All Contributors</a>\r\n  </div>\r\n  {{login}} - {{contributions}} contributions to Ember.js\r\n  \r\n  <ul>\r\n    <li><a {{action showDetails}}>Details</a></li>\r\n    <li><a {{action showRepos}}>Repos</a></li>\r\n  </ul>\r\n      \r\n  <div>\r\n    {{outlet}}\r\n  </div>\r\n</script>\r\n```\r\n    \r\nCreate the new transitions. I've placed them both within the 'aContributor'\r\nstate itself:\r\n\r\n\r\n```javascript\r\n  aContributor: Ember.Route.extend({       \r\n    showDetails: Ember.Route.transitionTo('details'),\r\n    showRepos: Ember.Route.transitionTo('repos')\r\n       \r\n   // ... remainder of the state's properties ...//\r\n  })\r\n```\r\n\r\nNow we can toggle between the two states. The `aContributor.repos` state will\r\nthrow an error because we're missing `ReposView`, which Ember is attempting to\r\nfind because of our `connectOutlet` call on router's `oneContributorController`:\r\n\r\n\r\n```javascript\r\n  connectOutlets: function(router){\r\n    router.get('oneContributorController').connectOutlet('repos')\r\n  }\r\n```\r\n      \r\nAdd the view and a template, again skipping the `ReposController` which will use\r\nthe shared `OneContributorController` instance as the rendering context for this\r\nview:\r\n\r\n\r\n```javascript\r\n  App.ReposView = Ember.View.extend({\r\n    templateName: 'repos'\r\n  })\r\n```\r\n```handlebars\r\n  <script type=\"text/x-handlebars\" data-template-name=\"repos\">\r\n    {{#each repo in repos}}\r\n       {{repo.name}}\r\n    {{/each}}\r\n  </script>\r\n```\r\n      \r\nFor the view I've just looped through the `repos` property of this view's\r\nrendering context, the shared `OneContributorController`.\r\n`OneContributorController` is an subclass of `ObjectController`, so this `repos`\r\nlookup is proxied along to the controller's `content` property. The `content`\r\nis an instance of `App.Contributor` we've passed along through the\r\n`{{action}}`, transition, and `connectOutlets` callback.\r\n\r\n\r\nReload the application, navigate back to this state, and you'll see a sad dearth\r\nof repos. As with 'aContributor.details' we need to request the appropriate data\r\nto display. Update the `connectOutlets` of 'aContributor.details' to include a\r\nstubbed method for fetching repos:\r\n\r\n```javascript\r\n  connectOutlets: function(router){\r\n    router.get('oneContributorController.content').loadRepos();\r\n    router.get('oneContributorController').connectOutlet('repos');\r\n  }\r\n```\r\n\r\nAnd implement this method on our `App.Contributor` model:\r\n\r\n```javascript\r\n  App.Contributor = Ember.Object.extend({\r\n    loadRepos: function(){\r\n      $.ajax({\r\n        url: 'https://api.github.com/users/%@/repos'.fmt(this.get('login')),\r\n        context: this,\r\n        dataType: 'jsonp',\r\n        success: function(response){\r\n          this.set('repos',response.data);\r\n        }\r\n      });\r\n    },\r\n    // other methods previously written\r\n  })\r\n```\r\n\r\nLike our data retrieval in 'aContributor.details' we now transition into the\r\n'aContributor.repos' state, trigger data retrieval and immediately update our\r\nviews. Once the data loading is complete, the view should automatically update\r\nto reflect the new value of our `repos` property.\r\n\r\nReader [@sly7_7](http://github.com/sly7_7) put together [a jsFiddle of the\r\ncompleted example](http://jsfiddle.net/Sly7/ZKXyg/).\r\n\r\n## Repeat, Repeat, Repeat\r\nYou'll be surprised how quickly you can express very advanced UIs by just\r\nrepeating this pattern. More importantly, your UIs will be crazy robust. The\r\nframework creates a small number of bindings and cleans them up when connections\r\nchange. Views tear themselves down and release memory automatically. Judicious\r\nseparation of states ensures users can't accidentally navigate into frustrating\r\nedge case scenarios.\r\n\r\nWhen your applications gets a bit larger than this example, start exploring\r\n[Ember Data](https://github.com/emberjs/data) to cut down the number of\r\nunnecessary ajax calls (and, more importantly, hide this interaction behind a\r\nnice API).\r\n\r\nYou made it through all my ranting and odd turns of phrase, so I'll share\r\nmy [secret](https://twitter.com/trek/status/239063773846052864) vision\r\nfor Ember: I want Ember to be a gateway drug for good UI \r\nengineering the way Rails was for good application development. You may\r\nscoff – \"Rails is bloated, I prefer express.js\" – but express is just\r\nstealing the best tricks from years of battle tested Rails experimentation.\r\n\r\nRails turned many of us from dabblers into developers and Ember\r\nhas that same feel of _rightness_ for me that Rails did in 2004.\r\nYou might reject Ember, but I hope it's after you've toyed with\r\nit and built something serious so you can reject it for substantive\r\nreasons or informed aesthetics, not simply because it seemed\r\nodd, new, or frighteningly different.\r\n\r\n> Copy-editing and proofing graciously provided by\r\n> [@frodsan](https://twitter.com/frodsan),\r\n> [@patrickbaselier](https://twitter.com/patrickbaselier), and\r\n> [@edimoldovan](https://twitter.com/edimoldovan). \r\n> Remaining foolish errors or omissions are mine.\r\n","google":""}