<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Trek by trek</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <link rel="stylesheet" href="stylesheets/prism.css">
    <script src="javascripts/scale.fix.js"></script>
    <script src="javascripts/prism.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Trek</h1>
        <p class="header"></p>



        <ul>
          <li><a class="buttons github" href="https://github.com/trek">GitHub Profile</a></li>
        </ul>

      </header>
      <section>
        <h1>Advice On &amp; Instruction in The Use of Ember.js</h1>

<p><a href="http://emberjs.com/">Ember.js</a> – for the unaware – is an application framework
for building sophisticated browser applications. I'm a frequent contributor to
the project and use it professionally at my current gig with <a href="http://www.groupon.com/techjobs/#/about">Groupon
Engineering</a>. This piece is part
tutorial, part marketing pitch.</p>

<p>There's currently a lot of interest in Ember and its
browser-application-crafting siblings as people are becoming more comfortable
with browser as a legitimate application development platform and not merely a
ubiquitously deployed rendering engine for server-generated documents. <a href="https://twitter.com/dhh/status/212655990766702594">Not
everyone</a> thinks this pattern
is viable moving forward, but I suspect interest in making this style of
application will only increase over time, become foolishly and inappropriately
overused, before finally settling down as a useful additional to a developer's
toolset.</p>

<p>I'm pretty convinced Ember will be the go-to choice for writing applications
with the sophistication, usefulness, and polish of products like
<a href="http://www.rdio.com/">Rdio</a>, <a href="https://squareup.com/">Square</a>'s web properties,
or <a href="http://get.wunderkit.com/apps/">Wunderkit</a>. Ember is the only framework I've
seen so far that is genuinely tackling the real and difficult requirements of UI
Engineering. I don't say this to knock projects like
<a href="http://batmanjs.org/">Batman</a>, <a href="http://knockoutjs.com/">Knockout</a>,
<a href="http://www.angularjs.org/">Angular</a>, or <a href="http://backbonejs.org/">Backbone</a>.
They're quite good; I've played with all and used Backbone professionally.</p>

<p>Like Ember, they're all experimenting with strategies for connecting data to
display and keeping the two synchronized – a notably difficult task. But only
Ember is approaching this task in a larger scope of UI Engineering that involves
even harder architecture concerns. This is part of what makes Ember.js
challenging for a learner to approach. Have you ever written an app that is
long-running, stateful, requires identity mapping, or must serialize state for
later re-entry? If you're like most web developers I meet, it's highly likely
these are all foreign or novel concepts for you. Even if you've encountered them
before in a CS class or while doing iOS development you've probably never
translated them into the browser environment.</p>

<p>Listen: it's not Ember that's hard. It's the concepts. When people tell me the
learning curve for Angular or Backbone is small, I call bullshit. Small for whom? Sure,
Backbone is approachable you've spent some time writing applications with jQuery
and are familiar with callback-style evented architectures. Backbone's DNA is
basically <a href="http://css-tricks.com/custom-events-are-pretty-cool/">jQuery custom
events</a> on steroids.
Angular is a dream if you're accustomed to HTML <code>data-</code> style behavior like
you find as part of <a href="http://twitter.github.com/bootstrap/javascript.html">Twitter Bootstrap's javascript</a></p>

<p>Even if Backbone fits squarely into your existing skill set – admittedly true
for most web developers – it's learning curve ramps up steeply if you're
dedicated to writing robust applications. Ever run into <a href="http://lostechies.com/derickbailey/2011/09/15/zombies-run-managing-page-transitions-in-backbone-apps/">zombie events in a
Backbone
application</a>?
No? You've either not used it for anything big, have <a href="http://www.imdb.com/title/tt0095953/">Rain
Man</a>-like ability to craft software, or
are fucking shitting me.</p>

<p>Here's an example of some of the view cleanup code in Rdio:</p>

<pre class="language-javascript"><code>destroy: function () {
  var c = this;
  this.unbind();
  try {
    this._element.pause(), 
    this._element.removeEventListener("error", this._triggerError), 
    this._element.removeEventListener("ended", this._triggerEnd), 
    this._element.removeEventListener("canplay", this._triggerReady), 
    this._element.removeEventListener("loadedmetadata", this._onLoadedMetadata), 
    _.each(b, function (a) {
      c._element.removeEventListener(a, c._bubbleProfilingEvent)
    }),
    _.each(a, function (a) {
      c._element.removeEventListener(a, c._logEvent)
    }),
    this._element = null,
    this.trigger("destroy")
  } catch (d) {}
}
</code></pre>

<p>If this doesn't look familiar, you're in for a world of hurt when you try to
parlay your Backbone skills into something Rdio-sized. Backbone is the best solution,
hands down, for apps where the user comes to a page, interacts with the application
for a short time before moving on, letting the <a href="https://github.com/documentcloud/backbone/issues/231">views and the models get thrown
away</a>. Beyond that,
it requires increasing diligence and expertise on your part.</p>

<p>So, here's my pitch: I want you to learn Ember. Not instead of Backbone or
Angular but <em>in addition to</em> them. There's a lot of writing comparing the three,
but once you become familiar with them you'll see it's a totally nonsensical
comparison. Although their output is the same (i.e. a "web app") they just don't
belong in the same category.</p>

<p>I apologize for the long preamble, but we're going to explore some concepts and
I want to be sure you're willing to allow that their strangeness is not due to
the poor architecture of Ember but to your unfamiliarity with them. If you're
willing to learn no matter how funky weird things appear at first, read on. If
you're looking to troll then just skim on: you'll find <em>lots</em> of things to
highlight <a href="https://twitter.com/delambro/status/234997274051219456">when you create a troll twitter account with a single post maligning
a tool you've never bothered to
explore</a>.</p>

<h2>The Smallest Viable Ember Application</h2>

<p>The smallest possible Ember application of interest can be describe thus:</p>

<pre class="language-javascript"><code>App = Ember.Application.create();

App.ApplicationView = Ember.View.extend({
  templateName: 'application'
});
App.ApplicationController = Ember.Controller.extend();


App.Router = Ember.Router.extend({
  root: Ember.Route.extend({
    index: Ember.Route.extend({
      route: '/'
    })
  })
});

App.initialize();
</code></pre>

<p>And in our HTML document body or head:</p>

<pre class="language-markup"><code>&lt;script type="text/x-handlebars" data-template-name="application"&gt;

&lt;/script&gt;
</code></pre>

<p>Let's examine each piece in isolation.</p>

<pre class="language-javascript"><code>App = Ember.Application.create();
</code></pre>

<p>This line creates a new instance of <code class="language-javascript">Ember.Application</code>. <code class="language-javascript">Application</code> does two handy things:</p>

<ul>
<li>provides a single location for all your objects so we avoid <a href="https://www.google.com/search?q=don't+pollute+the+global+namespace">polluting the global namespace</a>.</li>
<li>
<p>creates a single listener for each user event (e.g. 'click') and <a href="https://www.google.com/search?q=event+delegation">controls event delegation</a>.</p>

<p>
  <pre class="language-javascript">
    <code>
      App.ApplicationView = Ember.View.extend({
          templateName: 'application'
      });
    </code>
  </pre>
</p>
</li>
</ul><p>Views in Ember are responsible for:</p>

<ul>
<li>determining the structure of a section of the application's rendered HTML.</li>
<li>responding to delegated user events.</li>
</ul><p>In the above view we will change structure of the page only through the view's
template, which will render as the contents of the view's tag, but we could also
provide a different tag name, id, css class, or other HTML attributes for the
rendered element.</p>

<p>Your application <em>must</em> have an <code class="language-javascript">ApplicationView</code> property. An instance of this
class will be created for you and inserted into the application's view hierarchy
as the root view.</p>

<pre class="language-javascript"><code>App.ApplicationController = Ember.Controller.extend();
</code></pre>

<p>Every view has a rendering context. This is the object where Handlebars
templates will look for properties. So, if your template looks like this:</p>

<pre class="language-javascript"><code>{{name}}
</code></pre>

<p>and its rendering context has a <code>name</code> property, you'll see the value outputted.
If there is no property, you'll see nothing.</p>

<p>A single instance of <code>ApplicationController</code> will be created for you and
automatically set as the rendering context of the <code>ApplicationView</code>. This is
obvious but bears mentioning: your application <em>must</em> have an
<code>ApplicationController</code> property. If it lacked one, the application's root view
would have no rendering context and would be pretty useless except for
displaying static content. Ember enforces the presence of this property by
throwing and error if it's missing.</p>

<pre class="language-javascript"><code>App.Router = Ember.Router.extend({
  root: Ember.Route.extend({
    index: Ember.Route.extend({
      route: '/'
    })
  })
});
</code></pre>

<p>A <code>Router</code> in Ember behaves significantly different than you probably suspect
if you have experience with other javascript libraries using the 'router' label.
Ember's <code>Router</code> class is a subclass of its more general purpose <code>StateManager</code>.
Most browser-routers are just copying the routing pattern from familiar server
technologies. But HTTP is specifically a <a href="http://en.wikipedia.org/wiki/Stateless_protocol">stateless
protocol</a> and the techniques
for routing on the server are missing important abilities when translated into
the stateful environment of browser application development.</p>

<p>Your application's router is responsible for tracking the state of your
application and affecting the application's view hierarchy in response to state
change. It is also responsible for serializing this state into a single string –
the URL – and for later deserializing the string into a usable application
state. Rather than being a central organizing technique, URLs are just a useful
side effect of state change.</p>

<p>States are the central feature of an Ember application. Yes, property
observations and automatic view updates are handy, but if that's all Ember
offered it would be only a fraction as useful for serious and robust development.</p>

<pre class="language-javascript"><code>...
root: Ember.Route.extend({
  index: Ember.Route.extend({
    route: '/'
  })
})
...
</code></pre>

<p>Your router must have these two routes. The first, <code>root</code>, really just acts as a
container for all subsequent routes. You can think of it as the route set,
rather than a proper route itself. The second <code>index</code>, can be called whatever
you like. The key feature is that it has a <code>route</code> property of <code>'/'</code>. When your
application loads, Ember will being looking through its internal route maps to
find one that matches the url in the browser. If you enter the application at
the url <code>'/'</code> your Router will automatically transition into this state.</p>

<pre class="language-javascript"><code>App.initialize();
</code></pre>

<p>Finally, calling <code>initialize</code> on your application starts the application's
routing process, sets up the necessary internal structure based on configuration
we've done earlier, and inserts an instance of your <code>ApplicationView</code> (with an
instance of <code>ApplicationController</code> as its rending context) into the page.</p>

<h2>Building Up An Application</h2>

<p>From here, we can start building up an application by adding states to our
router, navigable elements in our templates to allow a user to begin
manipulating states, and views that are inserted in response to these state
changes. We'll create a tiny application that lets you see information about
committers to the main Ember repository.</p>

<p>Let's start that process by adding some markup and an <code>outlet</code> into our
currently empty <code>application</code> template:</p>

<pre class="language-markup"><code>&lt;script type="text/x-handlebars" data-template-name="application"&gt;
  &lt;h1&gt;Ember Committers&lt;/h1&gt;
  {{outlet}}
&lt;/script&gt;
</code></pre>

<p>An <code>outlet</code> helper defines sections of an template where we will change specific
portions of the view hierarchy in response to state change. Any template (not
just the root one) can have any number of outlets (if you give them names). This
lets you express really nuanced view hierarchies with minimal effort.</p>

<p>Next, add a view for all contributors and a matching controller and template:</p>

<pre class="language-javascript"><code>App.AllContributorsController = Ember.ArrayController.extend();
App.AllContributorsView = Ember.View.extend({
  templateName: 'contributors'
});

// in your page body or head:
&lt;script type="text/x-handlebars" data-template-name="contributors"&gt;
  {{#each person in controller}}
    {{person.login}}
  {{/each}}
&lt;/script&gt;
</code></pre>

<p>Within the state that matches for the index path (<code>'/'</code>), implement a
<code>connnectOutlets</code> method. It takes a single argument that will be your
application's router. Within that method get the single instance of our
<code>ApplicationController</code> class and connect its outlet with the <code>connnectOutlet</code>
method:</p>

<pre class="language-javascript"><code>index: Ember.Route.extend({
  route: '/',
  connnectOutlets: function(router){
    router.get('applicationController').connnectOutlet('allContributors', [{login:'wycats'},{login:'tomdale'}]);
  }
})
</code></pre>

<p>Give your application a reload. You won't see much yet, but this will let you
catch any console errors now.</p>

<p>Let me assuage your obvious fears right now: Yes, this is a lot of code. Yes, it
seems weirdly complex. Yes, you could accomplish this same trivial task in
Backbone or Angular with far less code. Ember isn't targeting applications with
this minimal level of sophistication so it seems foolishly verbose when starting
out.</p>

<p>That said, this is the <em>single</em> central pattern to an application. Once you
master it, you'll be cranking out applications like a pro. Ember applications
start out with a complexity rating of 4/10 but never get much higher than 6/10,
regardless of how sophisticated your application becomes. Backbone starts out at
1/10 but complexity grows linearly. This is a natural side effect of the types
of applications the two frameworks were specifically created for.</p>

<p>Let's unpack our new code, in reverse:</p>

<pre class="language-javascript"><code>index: Ember.Route.extend({
  route: '/',
  connnectOutlets: function(router){
    router.get('applicationController').connnectOutlet('allContributors', [{login:'wycats'},{login:'tomdale'}]);
  }
})
</code></pre>

<p>When your application is loaded at the url <code>'/'</code>, Ember will automatically
transition the application into the state I've called <code>index</code>. <code>connnectOutlets</code>
is called on this state. It acts as a callback for us to connect sections of our
view hierarchy (designated with <code>{{outlet}}</code>) to specific views based on the
state. In this case I want to connect the <code>{{outlet}}</code> in our application
template with markup for all our contributors so I access the application's
single shared instance of <code>ApplicationController</code> and call <code>connnectOutlet</code> on
it with <code>'allContributors'</code> as an argument.</p>

<p>When our application is <code>initialize</code>ed, a single shared instance of each
controller is created for us. Because you'll most likely access this instance
from the router, it's placed as a property of the router with a name that
matches the controller's classname but converted to lower-camel style:
<code>ApplicationController</code>'s single instance is stored as <code>applicationController</code>.</p>

<p>Controllers have the ability to connect outlets in the views they control. In the
above example, I'm calling <code>connnectOutlet</code> with <code>'allContributors'</code> as an argument.
This will create an instance of <code>AllContributorsView</code> for us, set the shared instance of
<code>AllContributorsController</code> as the view's default rendering context, and insert
it into our view hierarchy at the point where <code>{{outlet}}</code> appears in the
application template. The second argument, which I've hard coded as an array of
two object literals, is set as the <code>content</code> of the controller instance. (Those
who fear this kind of "magic" are free to read the documentation for Controllers
to see the full, maximally verbose and explicit arguments you can pass).</p>

<pre class="language-javascript"><code>App.AllContributorsController = Ember.ArrayController.extend();
App.AllContributorsView = Ember.View.extend({
  templateName: 'contributors'
});
</code></pre>

<p>The <code>AllContributorsController</code> is a subclass of Ember's <code>ArrayController</code> class.
<code>ArrayController</code>s acts as containers for any array-like object in Ember and
simply proxy undefined properties or methods to the underlying <code>content</code> array.</p>

<p>In our template, the each call (<code>{{each person in controller}}</code>) is passed along
to the <code>content</code> of our ArrayController which I've hard-coded as an array of two
object literals with a single property each.</p>

<pre class="language-markup"><code>&lt;script type="text/x-handlebars" data-template-name="contributors"&gt;
  {{#each person in controller}}
    {{person.login}}
  {{/each}}
&lt;/script&gt;
</code></pre>

<h2>Loading External Data</h2>

<p>Ember gets a lot of flack for it's lack of "a persistence layer" when compared
to Backbone or Batman. I've never thought of this as fair criticism because I
don't think of thin wrappers around <code>$.ajax()</code> that follow a Rails-style-REST
pattern really merit the "persistence layer" label. And many other frameworks
are starting to realize this too as their thin <code>$.ajax()</code> delegation is being
fleshed out to handle the <a href="https://plus.google.com/u/0/106300407679257154689/posts/Hv6xvZsuBBF">real and difficult problems of reliably synchronizing
data between two environments when there are few structural standards to rely
on</a>.</p>

<p>The real, valid criticism is that nobody who knows Ember has offered much
guidance for how to handle data loading within an Ember application. Ember, as
I'm trying to convince you, has valuable patterns you've never used before and
it's totally unfair to maintain this assertion while simultaneously expecting
you to know how to combine these patterns with data loading solutions you've
previously used.</p>

<p>The best advice I can offer is: always be returning.</p>

<p>Ember relies on the immediate availability of data objects even of the
underlying content of those objects is still loading. This is almost certainly
different than asynchronous patterns for data loading you've used
before. Let's step through how this works, once concern at a time.</p>

<p>In our application so far, I've punted on data and just hard coded something
into our index state:</p>

<pre class="language-javascript"><code>index: Ember.Route.extend({
  route: '/',
  connnectOutlets: function(router){
    router.get('applicationController').connnectOutlet('allContributors', [{login:'wycats'},{login:'tomdale'}]);
  }
})
</code></pre>

<p>I'd much prefer to delegate that data loading out to a proper object. Let's call
to a – as yet unimplemented – <code>Contributor</code> class and a <code>find</code> method on that class:</p>

<pre class="language-javascript"><code>index: Ember.Route.extend({
  route: '/',
  connnectOutlets: function(router){
    router.get('applicationController').connnectOutlet('allContributors', App.Contributor.find());
  }
})
</code></pre>

<p>And now implement this object:</p>

<pre class="language-javascript"><code>App.Contributor = Ember.Object.extend();
App.Contributor.reopenClass({
  find: function(){}
});
</code></pre>

<p>This creates a new class and reopens that class to add class (sometimes called
'static') method:</p>

<p>If you reload your application you'll see that nothing renders now. This is
because we've set the <code>content</code> of our <code>AllContributorsController</code> to undefined
which is the default return value of our new <code>find</code> method. Let's apply some
<code>$.ajax</code> to the method:</p>

<pre class="language-javascript"><code>App.Contributor.reopenClass({
  find: function(){
    $.ajax({
      url: 'https://api.github.com/repos/emberjs/ember.js/contributors',
      dataType: 'jsonp',
      success: function(response){
        return response.data;
    })
  }
});
</code></pre>

<p>Reload your application and you'll see there is still no change because,
although we request data, <code>find</code> still has no return value. It's here that
people usually code themselves into a corner trying to get their previous
experience with ajax to fit into Ember patterns, give up, and post a
StackOverflow question.</p>

<p>There are a few solutions to this problem but the easiest for us now is to just
make sure we're returning an array:</p>

<pre class="language-javascript"><code>App.Contributor.reopenClass({
  allContributors: [],
  find: function(){
    $.ajax({
      url: 'https://api.github.com/repos/emberjs/ember.js/contributors',
      dataType: 'jsonp',
      context: this,
      success: function(response){
        this.allContributors.addObjects(response.data);
    })
    return this.allContributors;
  }
});
</code></pre>

<p>I've changed <code>find</code> to immediately return an array (<code>this.allContributors</code>) which
starts out empty. This will become the <code>content</code> of our controller, which is the
default rendering context for the view. When the view first renders it will loop
over the empty array and insert nothing into the page. When the ajax call is
successful that same object is populated with data from the remote response and
Ember's property notification system will trigger a view re-render for just the
affected sections of the page.</p>

<p>Because Ember has a good property observation system we can handle the
asynchronicity from multiple points within the application structure where it's
most appropriate rather than being forced to handle it at the communication
layer.</p>

<p>If you reload the application you'll see an empty page before the view updates
when the data is loaded. If we were writing a slightly more complex application,
we could use a library by the core team called <a href="https://github.com/emberjs/data">Ember
Data</a> that would help with functionality like
binding loading state to view display. It has far more ambitious goals than
we'll need for demonstration: stateful data synchronization, property encoding
and decoding, identity mapping, transactional communication, and more.</p>

<h2>Transitioning Between States</h2>

<p>With data in hand, we can now allow users to transition between the state where
they see all contributors to a state where they see just one contributor. Our
current router looks like this</p>

<pre class="language-javascript"><code>App.Router = Ember.Router.extend({
  root: Ember.Route.extend({
    index: Ember.Route.extend({
      route: '/',
      connnectOutlets: function(router){
        router.get('applicationController').connnectOutlet('allContributors', App.Contributor.find());
      }
    })
  })
});
</code></pre>

<p>We'll add a sibling state to index for viewing just a single contributor. I'm
also going to rename 'index' to the more descriptive state name of
'contributors':</p>

<pre class="language-javascript"><code>App.Router = Ember.Router.extend({
  root: Ember.Route.extend({
    contributors: Ember.Route.extend({
      route: '/',
      connnectOutlets: function(router){
        router.get('applicationController').connnectOutlet('allContributors', App.Contributor.find());
      }
    }),

    aContributor: Ember.Route.extend({
      route: '/:githubUserName',
      connnectOutlets: function(router, context){
        router.get('applicationController').connnectOutlet('allContributors', context);
      }
    })

  })
});
</code></pre>

<p>Examining this new state in isolation:</p>

<pre class="language-javascript"><code>  aContributor: Ember.Route.extend({
    route: '/:githubUserName',
    connnectOutlets: function(router, context){
      router.get('applicationController').connnectOutlet('oneContributor', context);
    }
  })
</code></pre>

<p>I've supplied a <code>route</code> property of <code>':/githubUserName'</code>, which we'll use later
to serialize and deserialize this state. I've implemented the <code>connnectOutlets</code>
method with two arguments: one to represent the entire router and one, called
<code>context</code>, which will help answer the question "<em>which</em> contributor" later on.
Inside <code>connnectOutlets</code> I've accessed the shared instance of
<code>ApplicationController</code> and used it to connect the outlet in its view (an
instance of <code>ApplicationView</code>) to a pairing of
<code>OneContributorView</code>/<code>OneContributorController</code>, which are unimplemented.</p>

<p>Next, we'll update the application template to include a way for users to change
the application's state from 'contributors' to 'aContributor' through
interaction. Currently our template just loops and prints the <code>login</code> property
of each contributor:</p>

<pre class="language-markup"><code>  &lt;script type="text/x-handlebars" data-template-name="contributors"&gt;
    {{#each person in controller}}
      {{person.login}}
    {{/each}}
  &lt;/script&gt;
</code></pre>

<p>We're going to encase that login in an <code>&lt;a&gt;</code> tag that includes a call to the
<code>{{action}}</code> helper:</p>

<pre class="language-markup"><code>  &lt;script type="text/x-handlebars" data-template-name="contributors"&gt;
    {{#each person in controller}}
      &lt;a {{action showContributor person}}&gt; {{person.login}} &lt;/a&gt;
    {{/each}}
  &lt;/script&gt;
</code></pre>

<p>The <code>{{action}}</code> helper goes <em>within</em> the opening tag of an element (here, the
<code>&lt;a&gt;</code>) and takes two arguments. The first, <code>showContributor</code>, is the action we'd
like to send to the current state of the application and the second, <code>person</code>,
will become the <code>context</code> argument passed through various callbacks in the
application's router.</p>

<p>If you reload the application now you'll see that our logins have become links.
With your console enabled, click any of the links. You'll see a warning that
your application's router 'could not respond to event showContributor in state
root.contributors'.</p>

<p>Add this transition action to the 'contributors' state. I like to put my actions
between route property definition and route API callbacks like
<code>connnectOutlets</code>:</p>

<pre class="language-javascript"><code>contributors: Ember.Route.extend({
  route: '/',

  showContributor: Ember.Route.transitionTo('aContributor'),

  connnectOutlets: function(router){
    router.get('applicationController').connnectOutlet('allContributors', App.Contributor.find());
  }
})
</code></pre>

<p>The new action is written for us by the static method <code>transitionTo</code> on
the <code>Ember.Route</code> class. You can write your transitions yourself (they're just
functions), but <code>Ember.Route.transitionTo</code> saves you trouble of hand-writing
a lot of similar looking functions.</p>

<p>Pop back to the browser, reload the application, and try to transition again.
This time, you'll be warned that we're missing our <code>OneContributorView</code> class.
The transition has occurred and we've reached the <code>connnectOutlets</code> callback
on the 'aContributor' state, but cannot properly connect our outlet yet without
the missing view class.</p>

<p>Implement this class and matching controller and template:</p>

<pre class="language-javascript"><code>App.OneContributorView = Ember.View.extend({
  template: 'a-contributor'
});
App.OneContributorController = Ember.ObjectController.extend();

// in your HTML document
&lt;script type="text/x-handlebars" data-template-name="a-contributor"&gt;
  {{login}} - {{contributions}} contributions to Ember.js
&lt;/script&gt;
</code></pre>

<p>I've made <code>OneContributorController</code> an instance of <code>Ember.ObjectController</code>.
<code>ObjectController</code> is like <code>ArrayController</code> – a tiny wrapper for objects that will
just proxy property and method access to its underlying <code>content</code> property – but
for single objects instead of collections.</p>

<p>If you reload the application and try to transition you should have more
success. It might be handy to enable logging on your router to get a better feel
for what is happening on transitions:</p>

<pre class="language-javascript"><code>App.Router = Ember.Router.extend({
   enableLogging: true,
   // other properties added earlier
})
</code></pre>

<p>Let's unpack what's going on when we click that link. Ember has registered
listener on the <code>&lt;a&gt;</code> element for you (so, no, this is nothing like going back
to <em>ye olde onclick</em> days) that will call the matching action name
(<code>showContributor</code>) on the <code>target</code> property of the view. It just so happens
that the default target for any view is the application's router.</p>

<p>The router will delegate this action name to the current state. If the action is
present on the state, it will be called with the object you provided as the
second argument to <code>{{action}}</code> as a context argument. If it's not present, the
router will walk up through the state tree towards <code>root</code> looking for a matching
action name.</p>

<p>Since our state <em>does</em> have a matching name, 
<code>showContributor: Ember.Route.transitionTo('aContributor')</code>, it's called. This function
transitions the router to the name state ('aContributor') and calls its
<code>connnectOutlets</code> callback with the router as the first argument and the context
from the <code>{{action}}</code> helper as the second argument:</p>

<pre class="language-javascript"><code>connnectOutlets: function(route, context){
  router.get('applicationController').connnectOutlet('oneContributor', context);
}
</code></pre>

<p>Within this method, we access the single shared instance of
<code>ApplicationController</code> and connect the outlet in its view (an instance of
<code>ApplicationView</code>) by inserting an instance of <code>OneContributorView</code> with the
single shared instance of <code>OneContributorController</code> as its default rendering
context.</p>

<p>The <code>content</code> property of this controller is set to the passed <code>context</code>
argument. Since <code>OneContributorController</code> is a descendant of
<code>ObjectController</code>, property access in the view will proxy through the
controller to this <code>content</code>.</p>

<p>The view renders and we see our updated view hierarchy in the browser.</p>

<h2>Serializing and Deserializing States</h2>

<p>Observant readers will notice that, although we supplied a <code>route: '/:githubUserName'</code> 
property on our current state, the URL displayed
in the browser has updated to a value of '#/undefined'. I mentioned
earlier that URLs were just a pleasant side effect of state changes
but we haven't talked about serializing and deserializing states yet.</p>

<p>After an application state is entered and <code>connnectOutlets</code> has been called, the
router will call <code>serialize</code> on the state with the router itself as the first
argument and the current context as the second argument. There is a default
implementation of <code>serialize</code> that does property lookup on the context using any
dynamic slugs in the supplied <code>route</code> property as keys.</p>

<p>To have serialization work we can either update our <code>route</code> to include dynamic
slugs that match known properties on the object or implement our own custom
method.</p>

<pre class="language-javascript"><code>aContributor: Ember.Route.extend({
  route: '/:githubUserName',
  connnectOutlets: function(route, context){
    router.get('applicationController').connnectOutlet('oneContributor', context);
  },
  serialize: function(router, context){
    return {githubUserName: context.get('login')}
  }
})
</code></pre>

<p>The return value from a custom <code>serialize</code> method must be an object literal with
keys that match any dynamic slugs in the supplied <code>route</code>. The value for these
keys will be placed in the url.</p>

<p>Browse back to the root state of your application (i.e. go back to '/'), 
reload the application, and navigate back to the 'aContributor' state for any 
contributor. The url should update properly.</p>

<p>Unfortunately if you reload the application at this particular state you'll see
the URL updates to '#/undefined' again.</p>

<p>When we load an Ember application at a particular url it will attempt to match
and transition into a state with matching <code>route</code> pattern and call the state's
<code>connnectOutlets</code> and <code>serialize</code> callbacks. When we reload at '#/kselden', for
example, The router matches to the state with the <code>route</code> pattern of
'/:githubUserName', transitions into it, then calls <code>connnectOutlets</code> with the
router as the first argument and a second argument of ... no context at all.
Finally, <code>serialize</code> is called, also with an <code>undefined</code> context, and the
property <code>githubUserName</code> is accessed on <code>undefined</code> and the URL is updated to
'#/undefined'.</p>

<p>Entering the application at a particular URL doesn't give our application access
to previous loaded data so to fully load the matching state, we need to
re-access this data. States have a callback <code>deserialize</code> for doing just this.
There's a default implementation, but we can implement our own custom one as
well:</p>

<pre class="language-javascript"><code>aContributor: Ember.Route.extend({
  route: '/:githubUserName',
  connnectOutlets: function(route, context){
    router.get('applicationController').connnectOutlet('oneContributor', context);
  },
  serialize: function(router, context){
    return {githubUserName: context.get('login')}
  },
  deserialize: function(router, urlParams){
    return App.Contributor.findOne(urlParams.githubUserName);
  }
})
</code></pre>

<p>Above, I'm mocked out what I want this deserialization interface to look like.
I'll call <code>App.Contributor.findOne</code> with the section of our url represented by
<code>githubUserName</code> and return this object. The return value of <code>deserialize</code>
becomes the <code>context</code> passed to <code>connnectOutlets</code>, so I must immediately return
an object that will get populated with data later. Let's add
<code>App.Contributor.findOne</code> to allow for passing a Github user name. </p>

<p>Github allows us to access a user at '/users/<em>a name</em>', but this isn't within
the context of a particular repository, so we won't have access to this users
contribution count, which is part of the data we need. To see a particular
users in the context of a repository we'll need to load them all and locally
find the one we're looking for. This isn't exactly ideal, but unless you
control development of both client and server it's typical.</p>

<pre class="language-javascript"><code>findOne: function(username){
  var contributor = App.Contributor.create({
    login: username
  });

  $.ajax({
    url: 'https://api.github.com/repos/emberjs/ember.js/contributors',
    dataType: 'jsonp',
    context: contributor,
    success: function(response){
      this.setProperties(response.data.filterProperty('login', username));
    }
  })

  return contributor;
}
</code></pre>

<p>The order of execution for this method is: create a new <code>Contributor</code> object with
<code>login</code> set immediately to the know value passed in as <code>username</code> from within
the 'aContributor' states's deserialize method. Then we set up some ajax and
immediately return the <code>Contributor</code> instance. When the ajax completes we find
just the contributor we're interested in and update the returned <code>Contributor</code>
instance's properties with <code>setProperties</code>, which will trigger a view update of
any sections bound to properties whose values have changed.</p>

<h2>Repeat</h2>

<p>That's an Ember application. States, transitioning between them, and
loading data when you need it. You can build up surprisingly sophisticated and
robust UIs by repeating this process until you're happy. Let's repeat this by
add a "back to all contributors" navigation to our template for a single contributor:</p>

<p>Right now the template is pretty simple:</p>

<pre class="language-markup"><code>&lt;script type="text/x-handlebars" data-template-name="a-contributor"&gt;
  {{login}} - {{contributions}} contributions to Ember.js
&lt;/script&gt;
</code></pre>

<p>Let's add an element with an action to transition back to the 'contributors'
state:</p>

<pre class="language-markup"><code>&lt;script type="text/x-handlebars" data-template-name="a-contributor"&gt;
  &lt;div&gt;
    &lt;a {{action showAllContributors}}&gt;All Contributors&lt;/a&gt;
  &lt;/div&gt;
  {{login}} - {{contributions}} contributions to Ember.js
&lt;/script&gt;
</code></pre>

<p>Add this action to the 'aContributor' state:</p>

<pre class="language-javascript"><code>aContributor: Ember.Route.extend({
  route: '/:githubUserName',

  showAllContributors: Ember.Route.transitionTo('contributors')

  // ... remainder of this object's properties
})
</code></pre>

<p>Done.</p>

<p>Nested states are possible and encouraged as well. They come with only one
caveat: you must end the transition between states on state that is a 'leaf'
(i.e. has no child states of its own). As you convert states into more complex
sets of nested states, either remember to directly transition to one of the
child states or set an <code>initialState</code> property.</p>

<p>Let's convert our simple 'aContributor' state into a more complex object with
two child states. The parent 'aContributor' we'll use for fetching a contributor
and displaying her name and number of commits. Then we'll provide two nested
states: one – 'details' – for viewing additional details about the contributor
and a second – 'repos' – for showing a list of their repositories.</p>

<p>For reference, the 'aContributor' state looks like this:</p>

<pre class="language-javascript"><code>  aContributor: Ember.Route.extend({
    route: '/:githubUserName',
    connnectOutlets: function(route, context){
      router.get('applicationController').connnectOutlet('oneContributor', context);
    },
    serialize: function(router, context){
      return {githubUserName: context.get('login')}
    },
    deserialize: function(router, urlParams){
      return App.Contributor.findOne(urlParams.githubUserName);
    },
  })
</code></pre>

<p>And we'll change it to this:</p>

<pre class="language-javascript"><code>  aContributor: Ember.Route.extend({
    route: '/:githubUserName',
    connnectOutlets: function(route, context){
      router.get('applicationController').connnectOutlet('oneContributor', context);
    },
    serialize: function(router, context){
      return {githubUserName: context.get('login')}
    },
    deserialize: function(router, urlParams){
      return App.Contributor.findOne(urlParams.githubUserName);
    },

    // child states
    initialState: 'details',
    details: Ember.Route.extend({
      route: '/',
      connnectOutlets: function(router){
        router.get('oneContributorController').connectOutlet('details');
      }
    }),
    repos: Ember.Route.extend({
      route: '/repos',
      connnectOutlets: function(router){
        router.get('oneContributorController').connectOutlet('repos');
      }
    })
  })
</code></pre>

<p>Examining each state in isolation:</p>

<pre class="language-javascript"><code>initialState: 'details',
details: Ember.Route.extend({
  route: '/',
  connnectOutlets: function(router){
    router.get('oneContributorController').connectOutlet('details');
  }
})
</code></pre>

<p>When we transition into 'aContributor' its callbacks (<code>connnectOutlets</code>,
<code>serialize</code>, optionally <code>deserialize</code> is we're transitioning during application
load) are called. This means the <code>{{outlet}}</code> in our application template is
filled with an instance of <code>OneContributorView</code> with the the shared instance of
<code>OneContributorController</code> used as its default rendering context. The <code>context</code>
argument is passed from the <code>{{action showContributor contributor}}</code>, through
the transition, and into this callback. We then pass it along as the second
argument to <code>connnectOutlet</code> and it becomes the <code>content</code> property of the shared
<code>OneContributorController</code> instance.</p>

<p>Then, because we have <code>initialState</code> defined the router immediately transitions
into the state 'aContributor.details' and calls its <code>connnectOutlets</code> callback:</p>

<pre class="language-javascript"><code>connnectOutlets: function(router){
  router.get('oneContributorController').connectOutlet('details');
}
</code></pre>

<p>In this callback we're connecting an <code>{{outlet}}</code> that we'll place inside the
template for a contributor (yes, outlets can be nested inside other outlets as
deeply as you'd like to). Go ahead and change</p>

<pre class="language-markup"><code>&lt;script type="text/x-handlebars" data-template-name="a-contributor"&gt;
  &lt;div&gt;
    &lt;a {{action showAllContributors}}&gt;All Contributors&lt;/a&gt;
  &lt;/div&gt;
  {{login}} - {{contributions}} contributions to Ember.js
&lt;/script&gt;
</code></pre>

<p>to</p>

<pre class="language-markup"><code>&lt;script type="text/x-handlebars" data-template-name="a-contributor"&gt;
  &lt;div&gt;
    &lt;a {{action showAllContributors}}&gt;All Contributors&lt;/a&gt;
  &lt;/div&gt;
  {{login}} - {{contributions}} contributions to Ember.js

  &lt;div&gt;
    {{outlet}}
  &lt;/div&gt;
&lt;/script&gt;
</code></pre>

<p>And add <code>DetailsView</code> and template. You can skip creating a <code>DetailsController</code>.
In the absence of a controller with a matching name Ember will just use the
rendering context of the parent template, which in our case is the shared
instance of <code>OneContributorController</code> with its <code>context</code> property already set
to the contributor we're interested in:</p>

<pre class="language-javascript"><code>App.DetailsView = Ember.View.extend({
  templateName: 'details'
})

&lt;script type="text/x-handlebars" data-template-name="contributor-details"&gt;
  &lt;p&gt;{{email}}&lt;/p&gt;
  &lt;p&gt;{{bio}}&lt;/p&gt;
&lt;/script&gt;
</code></pre>

<p>Reload the app and navigate to the 'aContributor.details' state by clicking on a
Github username. If you have <code>enableLogging</code> on for your router you'll see we've
successfully transitioned into the state but are missing the <code>email</code> and <code>bio</code>
data. Unfortunately, these properties are not part of the contributor data that
comes from Github. We'll need to trigger a call to Github when we enter this
state to fetch additional details. Let's stub out a call to this in the
<code>connectOutlets</code> for 'aContributor.details':</p>

<pre class="language-javascript"><code>connnectOutlets: function(router){
  router.get('oneContributorController.content').loadMoreDetails();
  router.get('oneContributorController').connectOutlet('details');
}
</code></pre>

<p>And add this method to our <code>Contributor</code> model:</p>

<pre class="language-javascript"><code>App.Contributor = Ember.Object.extend({
  loadMoreDetails: function(){
    $.ajax({
      url: 'https://api.github.com/users/%@'.fmt(this.get('login')),
      context: this,
      dataType: 'jsonp',
      success: function(response){
        this.setProperties(response.data);
      })
    })
  }
});
</code></pre>

<p>Now when we enter this state we'll trigger a call to load more data from Github,
immediately render the view, and the view will automatically update when
additional properties eventually have values. You can now reload the application
and transition to this state again to see the updated view.</p>

<p>What about transitioning between our 'aContributor.details' and
'aContributor.repos' state? This should begin to look boringly familiar soon.
Update our view to provide some navigational elements. Currently it looks like
this:</p>

<pre class="language-markup"><code>&lt;script type="text/x-handlebars" data-template-name="a-contributor"&gt;
  &lt;div&gt;
    &lt;a {{action showAllContributors}}&gt;All Contributors&lt;/a&gt;
  &lt;/div&gt;
  {{login}} - {{contributions}} contributions to Ember.js

  &lt;div&gt;
    {{outlet}}
  &lt;/div&gt;
&lt;/script&gt;
</code></pre>

<p>And after we've added two actions:</p>

<pre class="language-markup"><code>&lt;script type="text/x-handlebars" data-template-name="a-contributor"&gt;
  &lt;div&gt;
    &lt;a {{action showAllContributors}}&gt;All Contributors&lt;/a&gt;
  &lt;/div&gt;
  {{login}} - {{contributions}} contributions to Ember.js

  &lt;ul&gt;
    &lt;li&gt;&lt;a {{action showDetails}}&gt;Details&lt;/a&gt;&lt;/li&gt;
    &lt;li&gt;&lt;a {{action showRepos}}&gt;Repos&lt;/a&gt;&lt;/li&gt;
  &lt;/ul&gt;

  &lt;div&gt;
    {{outlet}}
  &lt;/div&gt;
&lt;/script&gt;
</code></pre>

<p>Create the new transitions. I've placed them both within the 'aContributor'
state itself:</p>

<pre class="language-javascript"><code>  aContributor: Ember.Route.extend({       
    showDetails: Ember.Route.transitionTo('details'),
    showRepos: Ember.Route.transitionTo('repos')

   // ... remainder of the state's properties ...//
  })
</code></pre>

<p>Now we can toggle between the two states. The <code>aContributor.repos</code> state will
throw an error because we're missing <code>ReposView</code>, which Ember is attempting to
find because of our <code>connectOutlet</code> call on router's <code>oneContributorController</code>:</p>

<pre class="language-javascript"><code>  connnectOutlets: function(router){
    router.get('oneContributorController').connectOutlet('repos')
  }
</code></pre>

<p>Add the view and a template, again skipping the <code>ReposController</code> which will use
the shared <code>OneContributorController</code> instance as the rendering context for this
view:</p>

<pre class="language-javascript"><code>  App.ReposView = Ember.View.extend({
    templateName: 'repos'
  })

  &lt;script type="text/x-handlebars" data-template-name="repos"&gt;
    {{#each repo in repos}}
       {{repo.name}}
    {{/each}}
  &lt;/script&gt;
</code></pre>

<p>For the view I've just looped through the <code>repos</code> property of this view's
rendering context, the shared <code>OneContributorController</code>.
<code>OneContributorController</code> is an subclass of <code>ObjectController</code>, so this <code>repos</code>
lookup is proxied along to the controller's <code>content</code> property. The <code>content</code>
is an instance of <code>App.Contributor</code> we've passed along through the
<code>{{action}}</code>, transition, and <code>connectOutlets</code> callback.</p>

<p>Reload the application, navigate back to this state, and you'll see a sad dearth
of repos. As with 'aContributor.details' we need to request the appropriate data
to display. Update the <code>connectOutlets</code> of 'aContributor.details' to include a
stubbed method for fetching repos:</p>

<pre class="language-javascript"><code>  connnectOutlets: function(router){
    router.get('oneContributorController.content').loadRepos();
    router.get('oneContributorController').connectOutlet('repos');
  }
</code></pre>

<p>And implement this method on our <code>App.Contributor</code> model:</p>

<pre class="language-javascript"><code>  App.Contributor = Ember.Object.extend({
    loadRepos: function(){
      $.ajax({
        url: 'https://api.github.com/users/%@/repos'.fmt(this.get('login')),
        context: this,
        dataType: 'jsonp',
        success: function(response){
          this.set('repos',response.data);
        }
      });
    },
    // other methods previously written
  })
</code></pre>

<p>Like our data retrieval in 'aContributor.details' we now transition into the
'aContributor.repos' state, trigger data retrieval and immediately update our
views. Once the data loading is complete, the view should automatically update
to reflect the new value of our <code>repos</code> property.</p>

<h2>Repeat, Repeat, Repeat</h2>

<p>You'll be surprised how quickly you can express very advanced UIs by just
repeating this pattern. More importantly, your UIs will be crazy robust. The
framework creates a small number of bindings and cleans them up when connections
change. Views tear themselves down and release memory automatically. Judicious
separation of states ensures users can't accidentally navigate into frustrating
edge case scenarios.</p>

<p>When your applications gets a bit larger than this example, start exploring
<a href="https://github.com/emberjs/data">Ember Data</a> to cut down the number of
unnecessary ajax calls (and, more importantly, hide this interaction behind a
nice API).</p>

<p>You made it through all my ranting and odd turns of phrase, so I'll share
my <a href="https://twitter.com/trek/status/239063773846052864">secret</a> vision
for Ember: I want Ember to be a gateway drug for good UI 
engineering the way Rails was for good application development. You may
scoff – "Rails is bloated, I prefer express.js" – but express is just
stealing the best tricks from years of battle tested Rails experimentation.</p>

<p>Rails turned many of us from dabblers into developers and Ember
has that same feel of <em>rightness</em> for me that Rails did in 2004.
You might reject Ember but I hope it's after you've toyed with
it and built something serious so you can reject it for substantive
reasons or informed aesthetics, not simply because it seemed
odd, new, or frighteningly different.</p>

<blockquote>
<p>Copy-editing and proofing graciously provided by
<a href="https://twitter.com/frodsan">@frodsan</a>,
<a href="https://twitter.com/patrickbaselier">@patrickbaselier</a>, and
<a href="https://twitter.com/edimoldovan">@edimoldovan</a>. 
Remaining foolish errors or omissions are mine.</p>
</blockquote>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>